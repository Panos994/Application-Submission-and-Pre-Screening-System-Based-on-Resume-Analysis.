pipeline {
    agent any
    environment {
        BACKEND_IMAGE = 'ghcr.io/panos994/application-submission-and-pre-screening-system-based-on-resume-analysis/backend'
        FRONTEND_IMAGE = 'ghcr.io/panos994/application-submission-and-pre-screening-system-based-on-resume-frontend'
    }
    stages {
        stage('Get Version') {
            steps {
                script {
                    sh 'git checkout master'
                    def version = sh(script: "git describe --tags --always", returnStdout: true).trim()
                    echo "Using generated version: ${version}"

                    env.BACKEND_IMAGE = "${BACKEND_IMAGE}:${version}"
                    env.FRONTEND_IMAGE = "${FRONTEND_IMAGE}:${version}"
                }
            }
        }

        stage('Build Backend Image') {
            steps {
                script {
                    echo "Building backend Docker image"
                    sh '''
                    docker run --rm -v $(pwd):/app -w /app openjdk:17-alpine sh -c "
                    apk update && apk add --no-cache curl bash maven && \
                    mvn clean package -DskipTests"
                    '''
                    sh "docker build -t ${env.BACKEND_IMAGE} -f ./Dockerfile ."
                }
            }
        }

        stage('Build Frontend Image') {
            steps {
                script {
                    echo "Building frontend Docker image"
                    sh """
                    cd frontend/vue3-project-screening
                    docker build -t ${env.FRONTEND_IMAGE} -f ./Dockerfile .
                    """
                }
            }
        }

        stage('Docker Login to GHCR') {
            steps {
                script {
                    def github_username = "Panos994"
                    def github_token = "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"
                    // Log in to GHCR using the token and username
                    sh "echo ${github_token} | docker login ghcr.io -u ${github_username} --password-stdin"
                }
            }
        }

        stage('Push Images to GHCR') {
            parallel {
                stage('Push Backend') {
                    steps {
                        sh "docker push ${env.BACKEND_IMAGE}"
                    }
                }
                stage('Push Frontend') {
                    steps {
                        sh "docker push ${env.FRONTEND_IMAGE}"
                    }
                }
            }
        }

        stage('Pull Images on Deployment Server') {
            steps {
                script {
                    echo "Pulling backend and frontend Docker images on the server"
                    sh "docker pull ${env.BACKEND_IMAGE}"
                    sh "docker pull ${env.FRONTEND_IMAGE}"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            environment {
                KUBECONFIG = '/etc/rancher/k3s/k3s.yaml'
            }
            steps {
                script {
                    sh '''
                    sudo kubectl apply -f k3s/database/deployment.yaml
                    sudo kubectl apply -f k3s/database/service.yaml
                    sudo kubectl apply -f k3s/minio
                    sudo kubectl apply -f k3s/backend/deployment.yaml
                    sudo kubectl apply -f k3s/backend/service.yaml
                    sudo kubectl apply -f k3s/frontend/deployment.yaml
                    sudo kubectl apply -f k3s/frontend/service.yaml
                    '''

                    // Set images for deployments
                    sh "sudo kubectl set image deployment/spring-backend spring-backend=${env.BACKEND_IMAGE} --record"
                    sh "sudo kubectl set image deployment/vue-frontend vue-frontend=${env.FRONTEND_IMAGE} --record"

                    // Rollout verification with enhanced error handling
                    try {
                        echo "Waiting for backend rollout to finish..."
                        sh "sudo kubectl rollout status deployment/spring-backend --timeout=100s"

                        echo "Waiting for frontend rollout to finish..."
                        sh "sudo kubectl rollout status deployment/vue-frontend --timeout=100s"
                    } catch (Exception e) {
                        echo "Deployment failed! Error: ${e.message}"
                        currentBuild.result = 'FAILURE'
                        error("Kubernetes rollout failed")
                    }
                }
            }
        }
    }
}



//added Build part (Build backend and Build Frontend + Push to the container registry)
//added semantic versioning method: Get Version stage generates a version using --> def version = "1.0.0-${commitHash}"
//This creates a version based on a fixed major, minor, and patch number (1.0.0) combined with the short commit hash. This kind of mechanism ensures that each build has a unique version tied to the Git commit.



//Definition of semantic versioning:
//Semantic Versioning (SemVer) is a versioning scheme designed to convey meaning about the underlying changes in a software release. It follows a structured format of MAJOR.MINOR.PATCH and is widely used in software development to manage and communicate version updates effectively.
  //Format: MAJOR.MINOR.PATCH

    //  MAJOR version (e.g., 1.0.0):
    //  Incremented when making backward-incompatible changes. This indicates that changes might break existing dependencies.

   //   MINOR version (e.g., 1.1.0):
   //   Incremented when adding backward-compatible features. New functionalities are introduced without breaking existing code.

   //   PATCH version (e.g., 1.0.1):
    //  Incremented when making backward-compatible bug fixes. This covers minor improvements or corrections that don't affect the public API.

  //Examples:

      //1.2.3
      //    1: Major version → Significant, breaking changes.
       //   2: Minor version → New features, but backward-compatible.
      //    3: Patch version → Bug fixes or small improvements.

//  Additional Labels:

    //  Pre-release versions:
   //   For versions under development (e.g., 1.0.0-beta, 1.2.3-alpha).
  //    Build metadata:
  //    Used for additional build info (e.g., 1.0.0+build.123).

  //Why Use Semantic Versioning?

     // Clarity:
    //  Easily understand the impact of an update.
    //  Dependency management:
   //   Helps teams or systems determine whether to upgrade.
    //  Consistency:
    //  Standardizes version control across teams or projects.

  //Workflow:

    //  Bug fix: Update the PATCH version (e.g., 1.0.0 → 1.0.1).
  //    New feature: Update the MINOR version (e.g., 1.0.0 → 1.1.0).
   //   Breaking change: Update the MAJOR version (e.g., 1.0.0 → 2.0.0).

  //Tools for Automation:

   //   Manual control: Maintain version numbers in a VERSION file.
    //  Automated: Tools like semantic-release automate version management based on commit messages.

  //Semantic versioning provides a clear and predictable way to handle software updates, ensuring users and developers understand changes and compatibility.